import { NextResponse } from 'next/server';
import TelegramBot from 'node-telegram-bot-api';

// Initialize bot with token from environment
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: false });

// In-memory storage for alerts (in production, use database)
const userAlerts = new Map();

export async function POST(request) {
  try {
    const body = await request.json();
    
    // Handle Telegram webhook
    if (body.message) {
      await handleMessage(body.message);
    } else if (body.callback_query) {
      await handleCallbackQuery(body.callback_query);
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Telegram webhook error:', error);
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });
  }
}

async function handleMessage(message) {
  const chatId = message.chat.id;
  const text = message.text || '';
  const userId = message.from.id;

  console.log(`üì± Telegram message from ${userId}: ${text}`);

  if (text.startsWith('/start')) {
    await sendWelcomeMessage(chatId);
  } else if (text.startsWith('/setalert')) {
    await handleSetAlert(chatId, text, userId);
  } else if (text.startsWith('/myalerts')) {
    await handleMyAlerts(chatId, userId);
  } else if (text.startsWith('/deletealert')) {
    await handleDeleteAlert(chatId, text, userId);
  } else if (text.startsWith('/help')) {
    await sendHelpMessage(chatId);
  } else {
    await sendUnknownCommand(chatId);
  }
}

async function handleCallbackQuery(callbackQuery) {
  const chatId = callbackQuery.message.chat.id;
  const data = callbackQuery.data;
  const userId = callbackQuery.from.id;

  console.log(`üîò Callback query from ${userId}: ${data}`);

  if (data.startsWith('delete_')) {
    const alertId = data.replace('delete_', '');
    await deleteAlert(chatId, alertId, userId);
  }
}

async function sendWelcomeMessage(chatId) {
  const message = `üöÄ Welcome to the Token Alert Bot!

I'll help you set up buy and sell alerts for your mainnet tokens.

Available commands:
/setalert - Set a new price alert
/myalerts - View your current alerts
/deletealert - Delete an alert
/help - Show help information

To set an alert, use:
/setalert <token_symbol> <price> <type>

Examples:
/setalert MAS 0.50 buy
/setalert MAS 1.00 sell

Let's get started! üéØ`;

  await bot.sendMessage(chatId, message);
}

async function sendHelpMessage(chatId) {
  const message = `üìö Help - Token Alert Bot

Commands:
‚Ä¢ /setalert <symbol> <price> <type> - Set price alert
‚Ä¢ /myalerts - View your alerts
‚Ä¢ /deletealert <id> - Delete specific alert
‚Ä¢ /help - Show this help

Examples:
‚Ä¢ /setalert MAS 0.50 buy - Alert when MAS drops to $0.50
‚Ä¢ /setalert MAS 1.00 sell - Alert when MAS reaches $1.00

Alert Types:
‚Ä¢ buy - Notify when price drops to target (buy opportunity)
‚Ä¢ sell - Notify when price rises to target (sell opportunity)

Current supported tokens: MAS, and other mainnet tokens`;

  await bot.sendMessage(chatId, message);
}

async function handleSetAlert(chatId, text, userId) {
  try {
    const parts = text.split(' ');
    if (parts.length !== 4) {
      await bot.sendMessage(chatId, 
        '‚ùå Invalid format. Use: /setalert <symbol> <price> <type>\n' +
        'Example: /setalert MAS 0.50 buy'
      );
      return;
    }

    const symbol = parts[1].toUpperCase();
    const price = parseFloat(parts[2]);
    const type = parts[3].toLowerCase();

    if (isNaN(price) || price <= 0) {
      await bot.sendMessage(chatId, '‚ùå Invalid price. Please enter a valid number.');
      return;
    }

    if (!['buy', 'sell'].includes(type)) {
      await bot.sendMessage(chatId, '‚ùå Invalid type. Use "buy" or "sell".');
      return;
    }

    // Generate unique alert ID
    const alertId = `${userId}_${Date.now()}`;
    
    // Store alert
    if (!userAlerts.has(userId)) {
      userAlerts.set(userId, []);
    }
    
    const alert = {
      id: alertId,
      symbol,
      price,
      type,
      createdAt: new Date().toISOString(),
      active: true
    };
    
    userAlerts.get(userId).push(alert);

    const message = `‚úÖ Alert set successfully!

üìä Token: ${symbol}
üí∞ Target Price: $${price}
üéØ Type: ${type === 'buy' ? 'Buy Alert' : 'Sell Alert'}
üÜî Alert ID: ${alertId}

You'll be notified when the price reaches your target! üîî`;

    await bot.sendMessage(chatId, message);
    
    console.log(`üîî Alert set for user ${userId}: ${symbol} ${type} at $${price}`);

  } catch (error) {
    console.error('Error setting alert:', error);
    await bot.sendMessage(chatId, '‚ùå Error setting alert. Please try again.');
  }
}

async function handleMyAlerts(chatId, userId) {
  try {
    const alerts = userAlerts.get(userId) || [];
    
    if (alerts.length === 0) {
      await bot.sendMessage(chatId, 'üì≠ You have no active alerts.\nUse /setalert to create one!');
      return;
    }

    let message = `üìã Your Active Alerts (${alerts.length}):\n\n`;
    
    alerts.forEach((alert, index) => {
      message += `${index + 1}. ${alert.symbol} - $${alert.price} (${alert.type})\n`;
      message += `   ID: ${alert.id}\n`;
      message += `   Created: ${new Date(alert.createdAt).toLocaleDateString()}\n\n`;
    });

    message += 'To delete an alert, use: /deletealert <alert_id>';

    await bot.sendMessage(chatId, message);

  } catch (error) {
    console.error('Error fetching alerts:', error);
    await bot.sendMessage(chatId, '‚ùå Error fetching alerts. Please try again.');
  }
}

async function handleDeleteAlert(chatId, text, userId) {
  try {
    const parts = text.split(' ');
    if (parts.length !== 2) {
      await bot.sendMessage(chatId, '‚ùå Invalid format. Use: /deletealert <alert_id>');
      return;
    }

    const alertId = parts[1];
    const alerts = userAlerts.get(userId) || [];
    
    const alertIndex = alerts.findIndex(alert => alert.id === alertId);
    
    if (alertIndex === -1) {
      await bot.sendMessage(chatId, '‚ùå Alert not found. Check your alert ID with /myalerts');
      return;
    }

    const deletedAlert = alerts.splice(alertIndex, 1)[0];
    userAlerts.set(userId, alerts);

    await bot.sendMessage(chatId, 
      `üóëÔ∏è Alert deleted successfully!\n\n` +
      `üìä Token: ${deletedAlert.symbol}\n` +
      `üí∞ Price: $${deletedAlert.price}\n` +
      `üéØ Type: ${deletedAlert.type}`
    );

    console.log(`üóëÔ∏è Alert deleted for user ${userId}: ${deletedAlert.symbol}`);

  } catch (error) {
    console.error('Error deleting alert:', error);
    await bot.sendMessage(chatId, '‚ùå Error deleting alert. Please try again.');
  }
}

async function deleteAlert(chatId, alertId, userId) {
  try {
    const alerts = userAlerts.get(userId) || [];
    const alertIndex = alerts.findIndex(alert => alert.id === alertId);
    
    if (alertIndex === -1) {
      await bot.sendMessage(chatId, '‚ùå Alert not found.');
      return;
    }

    const deletedAlert = alerts.splice(alertIndex, 1)[0];
    userAlerts.set(userId, alerts);

    await bot.sendMessage(chatId, 
      `üóëÔ∏è Alert deleted!\n${deletedAlert.symbol} - $${deletedAlert.price} (${deletedAlert.type})`
    );

  } catch (error) {
    console.error('Error deleting alert:', error);
    await bot.sendMessage(chatId, '‚ùå Error deleting alert.');
  }
}

async function sendUnknownCommand(chatId) {
  await bot.sendMessage(chatId, 
    '‚ùì Unknown command. Use /help to see available commands.'
  );
}

// Export for use in price monitoring
export { userAlerts, bot };
